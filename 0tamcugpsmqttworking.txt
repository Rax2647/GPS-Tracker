#define ESP32_RTOS  // Uncomment this line if you want to use the code with freertos only on the ESP32
// Has to be done before including "OTA.h"

#include "OTA.h"
#include "Credentials.h"
#include "Adafruit_FONA.h"
#include "Adafruit_MQTT.h"
#include "Adafruit_MQTT_FONA.h"
#define SIMCOM_7000


// ESP8266 + SIM7000 evb board
#define FONA_PWRKEY 14 // D5 on NodeMCU
#define FONA_RST 12 // D6 on NodeMCU
#define FONA_TX 4 // D2 on NodeMCU, microcontroller RX
#define FONA_RX 5 // D1 on NodeMCU, microcontroller TX




#define LED 13 // Just for testing if needed!

#define samplingRate 15 // The time we want to delay after each post (in seconds)

#include <SoftwareSerial.h>

//telnet script
uint32_t entry;






SoftwareSerial fonaSS = SoftwareSerial(FONA_TX, FONA_RX);
// Use the following line for ESP8266 instead of the line above (comment out the one above)
//SoftwareSerial fonaSS = SoftwareSerial(FONA_TX, FONA_RX, false, 256); // TX, RX, inverted logic, buffer size

SoftwareSerial *fonaSerial = &fonaSS;

// Use this for 2G modules
#ifdef SIMCOM_2G
Adafruit_FONA fona = Adafruit_FONA(FONA_RST);

// Use this one for 3G modules
#elif defined(SIMCOM_3G)
Adafruit_FONA_3G fona = Adafruit_FONA_3G(FONA_RST);

// Use this one for LTE CAT-M/NB-IoT modules (like SIM7000)
// Notice how we don't include the reset pin because it's reserved for emergencies on the LTE module!
#elif defined(SIMCOM_7000) || defined(SIMCOM_7070) || defined(SIMCOM_7500) || defined(SIMCOM_7600)
Adafruit_FONA_LTE fona = Adafruit_FONA_LTE();
#endif

/************************* MQTT SETUP *********************************/
// MQTT setup (if you're using it, that is)
// For Adafruit IO:
#define AIO_SERVER      "io.adafruit.com"
#define AIO_SERVERPORT  1883
#define AIO_USERNAME    ""
#define AIO_KEY         ""

// Setup the FONA MQTT class by passing in the FONA class and MQTT server and login details.
Adafruit_MQTT_FONA mqtt(&fona, AIO_SERVER, AIO_SERVERPORT, AIO_USERNAME, AIO_KEY);

// How many transmission failures in a row we're OK with before reset
uint8_t txfailures = 0;

/****************************** MQTT FEEDS ***************************************/
// Setup feeds for publishing.
// Notice MQTT paths for Adafruit IO follow the form: <username>/feeds/<feedname>
// Also notice that the combined lat/long "location" feed requires "/csv" in the name
// The Adafruit IO map requires this format: sensor_val, lat, long, altitude
Adafruit_MQTT_Publish feed_location = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/location/csv"); // Group GPS data for AIO map in dashboard
Adafruit_MQTT_Publish feed_speed = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/speed");
Adafruit_MQTT_Publish feed_head = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/heading");
Adafruit_MQTT_Publish feed_alt = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/altitude");
//Adafruit_MQTT_Publish feed_temp = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/temperature");
Adafruit_MQTT_Publish feed_voltage = Adafruit_MQTT_Publish(&mqtt, AIO_USERNAME "/feeds/voltage");

// Setup a feed called 'command' for subscribing to changes.
Adafruit_MQTT_Subscribe feed_command = Adafruit_MQTT_Subscribe(&mqtt, AIO_USERNAME "/feeds/command");

/****************************** OTHER STUFF ***************************************/

const int voltageSensor = A0;

float vOUT = 0.0;
float v = 0.0;
float R1 = 30000.0;
float R2 = 7500.0;
int value = 0;



uint8_t readline(char *buff, uint8_t maxbuff, uint16_t timeout = 0);
char imei[16] = {0}; // Use this for device ID
uint8_t type;
uint16_t battLevel = 0; // Battery level (percentage)
float latitude, longitude, speed_kph, heading, altitude, second;
uint16_t year;
uint8_t month, day, hour, minute;
uint8_t counter = 0;
//char PIN[5] = "1234"; // SIM card PIN

// NOTE: Keep the buffer sizes as small as possible, espeially on
// Arduino Uno which doesn't have much computing power to handle
// large buffers. On Arduino Mega you shouldn't have to worry much.
char latBuff[12], longBuff[12], locBuff[50], speedBuff[12],
     headBuff[12], altBuff[12], tempBuff[12], battBuff[12];



void setup() {
  pinMode(LED_BUILTIN, OUTPUT);



  Serial.begin(115200);
  Serial.println("Booting....");
  TelnetStream.println("Booting....");

  Serial.println("File "__FILE__" Built on " __DATE__ " at "__TIME__);
  TelnetStream.println("File "__FILE__" Built on " __DATE__ " at "__TIME__);
   
  setupOTA("BeastMCU", mySSID, myPASSWORD);
  ArduinoOTA.handle();
  delay(5000);

  // Your setup code
  Serial.println(F("*** SIMCom Module MQTT Example ***"));
  TelnetStream.println(micros()-entry);
  TelnetStream.println("*** SIMCom Module MQTT Example ***");
  delay(1000);
  
#ifdef LED
  pinMode(LED, OUTPUT);
  digitalWrite(LED, LOW);
#endif

  pinMode(FONA_RST, OUTPUT);
  digitalWrite(FONA_RST, HIGH); // Default state

  fona.powerOn(FONA_PWRKEY); // Power on the module
  moduleSetup(); // Establishes first-time serial comm and prints IMEI

  // Set modem to full functionality
  fona.setFunctionality(1); // AT+CFUN=1

  fona.setNetworkSettings(F("m2m64.com.attz")); // For AT&T IoT SIM card

  fona.enableGPS(true);

  // Perform first-time GPS/data setup if the shield is going to remain on,
  // otherwise these won't be enabled in loop() and it won't work!
  // Enable GPS
  while (!fona.enableGPS(true)) {
    digitalWrite(LED_BUILTIN, LOW);   // Turn the LED on by making the voltage LOW
    delay(500);                      // Wait for .5 second
    digitalWrite(LED_BUILTIN, HIGH);  // Turn the LED off by making the voltage HIGH
    delay(500);                      // Wait for .5 seconds
    digitalWrite(LED_BUILTIN, LOW);   // Turn the LED on by making the voltage LOW
    delay(500);                      // Wait for .5 second
    digitalWrite(LED_BUILTIN, HIGH);  // Turn the LED off by making the voltage HIGH
    delay(500);                      // Wait for .5 seconds
    digitalWrite(LED_BUILTIN, LOW);   // Turn the LED on by making the voltage LOW
    delay(500);                      // Wait for .5 second
    digitalWrite(LED_BUILTIN, HIGH);  // Turn the LED off by making the voltage HIGH
    delay(500);                      // Wait for .5 seconds
    
    Serial.println(F("Failed to turn on GPS, retrying..."));
    delay(5000); // Retry every 5s
    TelnetStream.println(micros()-entry);
    TelnetStream.println("Failed to turn on GPS, retrying...");

    
    digitalWrite(LED_BUILTIN, LOW);   // Turn the LED on by making the voltage LOW
    delay(500);                      // Wait for .5 second
    digitalWrite(LED_BUILTIN, HIGH);  // Turn the LED off by making the voltage HIGH
    delay(500);                      // Wait for .5 seconds
    digitalWrite(LED_BUILTIN, LOW);   // Turn the LED on by making the voltage LOW
    delay(500);                      // Wait for .5 second
    digitalWrite(LED_BUILTIN, HIGH);  // Turn the LED off by making the voltage HIGH
    delay(500);                      // Wait for .5 seconds
    digitalWrite(LED_BUILTIN, LOW);   // Turn the LED on by making the voltage LOW
    delay(500);                      // Wait for .5 second
    digitalWrite(LED_BUILTIN, HIGH);  // Turn the LED off by making the voltage HIGH
    delay(500);                      // Wait for .5 seconds

  
  }
  Serial.println(F("Turned on GPS!"));
  TelnetStream.println(micros()-entry);
  TelnetStream.println("Loop");


  // Turn on data
  while (!fona.enableGPRS(true)) {
    Serial.println(F("Failed to enable data, retrying..."));
      TelnetStream.println(micros()-entry);
      TelnetStream.println("Failed to enable data, retrying...");
    delay(2000); // Retry every 2s
    digitalWrite(LED_BUILTIN, LOW);   // Turn the LED on by making the voltage LOW
    delay(500);                      // Wait for .5 second
    digitalWrite(LED_BUILTIN, HIGH);  // Turn the LED off by making the voltage HIGH
    delay(500);                      // Wait for .5 seconds
    digitalWrite(LED_BUILTIN, LOW);   // Turn the LED on by making the voltage LOW
    delay(500);                      // Wait for .5 second
    digitalWrite(LED_BUILTIN, HIGH);  // Turn the LED off by making the voltage HIGH
    delay(500);                      // Wait for .5 seconds
    digitalWrite(LED_BUILTIN, LOW);   // Turn the LED on by making the voltage LOW
    delay(500);                      // Wait for .5 second
    digitalWrite(LED_BUILTIN, HIGH);  // Turn the LED off by making the voltage HIGH
    delay(500);                      // Wait for .5 seconds
  }
  Serial.println(F("Enabled data!"));
    TelnetStream.println(micros()-entry);
    TelnetStream.println("Enabled data!");

  mqtt.subscribe(&feed_command); // Only if you're using MQTT

}

void loop() {
  ArduinoOTA.handle();
  Serial.println("File "__FILE__" Built on " __DATE__ " at "__TIME__);
  TelnetStream.println("File "__FILE__" Built on " __DATE__ " at "__TIME__);
  ArduinoOTA.handle();
  delay(5000);
  
  value = analogRead(voltageSensor);
  vOUT = (value * 3.20) / 1024.0;
  v = vOUT / (R2 / (R1 + R2));


  entry = micros();
#ifdef defined(ESP32_RTOS) && defined(ESP32)
#else // If you do not use FreeRTOS, you have to regulary call the handle method.
  ArduinoOTA.handle();
#endif

  // Your code here
  // Connect to cell network and verify connection
  // If unsuccessful, keep retrying every 2s until a connection is made
  while (!netStatus()) {
    digitalWrite(LED_BUILTIN, LOW);   // Turn the LED on by making the voltage LOW
    delay(500);                      // Wait for .5 second
    digitalWrite(LED_BUILTIN, HIGH);  // Turn the LED off by making the voltage HIGH
    delay(500);                      // Wait for .5 seconds
    digitalWrite(LED_BUILTIN, LOW);   // Turn the LED on by making the voltage LOW
    delay(500);                      // Wait for .5 second
    digitalWrite(LED_BUILTIN, HIGH);  // Turn the LED off by making the voltage HIGH
    delay(500);                      // Wait for .5 seconds
    digitalWrite(LED_BUILTIN, LOW);   // Turn the LED on by making the voltage LOW
    delay(500);                      // Wait for .5 second
    digitalWrite(LED_BUILTIN, HIGH);  // Turn the LED off by making the voltage HIGH
    delay(500);                      // Wait for .5 seconds
    
    Serial.println(F("Failed to connect to cell network, retrying..."));
        TelnetStream.println(micros()-entry);
        TelnetStream.println("Failed to connect to cell network, retrying...");
    delay(2000); // Retry every 2s
    digitalWrite(LED_BUILTIN, LOW);   // Turn the LED on by making the voltage LOW
    delay(500);                      // Wait for .5 second
    digitalWrite(LED_BUILTIN, HIGH);  // Turn the LED off by making the voltage HIGH
    delay(500);                      // Wait for .5 seconds
    digitalWrite(LED_BUILTIN, LOW);   // Turn the LED on by making the voltage LOW
    delay(500);                      // Wait for .5 second
    digitalWrite(LED_BUILTIN, HIGH);  // Turn the LED off by making the voltage HIGH
    delay(500);                      // Wait for .5 seconds
    digitalWrite(LED_BUILTIN, LOW);   // Turn the LED on by making the voltage LOW
    delay(500);                      // Wait for .5 second
    digitalWrite(LED_BUILTIN, HIGH);  // Turn the LED off by making the voltage HIGH
    delay(500);                      // Wait for .5 seconds

  }
  Serial.println(F("Connected to cell network!"));
    TelnetStream.println(micros()-entry);
    TelnetStream.println("Connected to cell network!");
  

  // Measure battery voltage in mV
  battLevel = v;

  fona.enableGPS(true);

  // Get a fix on location, try every 2s
  // Use the top line if you want to parse UTC time data as well, the line below it if you don't care
  //  while (!fona.getGPS(&latitude, &longitude, &speed_kph, &heading, &altitude, &year, &month, &day, &hour, &minute, &second)) {
  while (!fona.getGPS(&latitude, &longitude, &speed_kph, &heading, &altitude)) {
    Serial.println(F("Failed to get GPS location, retrying..."));
     TelnetStream.println(micros()-entry);
      TelnetStream.println("Failed to get GPS location, retrying...");
    
    delay(15000); // Retry every 15s
    digitalWrite(LED_BUILTIN, LOW);   // Turn the LED on by making the voltage LOW
    delay(2000);                      // Wait for two second
    digitalWrite(LED_BUILTIN, HIGH);  // Turn the LED off by making the voltage HIGH
    delay(2000);                      // Wait for two seconds
    digitalWrite(LED_BUILTIN, LOW);   // Turn the LED on by making the voltage LOW
    delay(2000);                      // Wait for two second
    digitalWrite(LED_BUILTIN, HIGH);  // Turn the LED off by making the voltage HIGH
    delay(2000);                      // Wait for two seconds
    digitalWrite(LED_BUILTIN, LOW);   // Turn the LED on by making the voltage LOW
    delay(2000);                      // Wait for two second
    digitalWrite(LED_BUILTIN, HIGH);  // Turn the LED off by making the voltage HIGH
    delay(2000);                      // Wait for two seconds
  }
  Serial.println(F("Found 'eeeeem!"));
    TelnetStream.println(micros()-entry);
  TelnetStream.println("Found 'eeeeem!");
  Serial.println(F("---------------------"));
    TelnetStream.println(micros()-entry);
  TelnetStream.println("---------------------");
  Serial.print(F("Latitude: ")); Serial.println(latitude, 6);
    TelnetStream.println(micros()-entry);
  TelnetStream.println("Latitude: ");
  Serial.print(F("Longitude: ")); Serial.println(longitude, 6);
    TelnetStream.println(micros()-entry);
  TelnetStream.println("Longitude: ");
  Serial.print(F("Speed: ")); Serial.println(speed_kph);
    TelnetStream.println(micros()-entry);
  TelnetStream.println("Speed: ");
  Serial.print(F("Heading: ")); Serial.println(heading);  
  TelnetStream.println(micros()-entry);
  TelnetStream.println("Heading: ");
  Serial.print(F("Altitude: ")); Serial.println(altitude);
    TelnetStream.println(altitude);
  TelnetStream.println("Altitude: ");  
  Serial.print(F("Battlevel: ")); Serial.println(v);
    TelnetStream.println(micros()-v);
  TelnetStream.println("Battlevel: ");

  // Uncomment this if you care about parsing UTC time
  Serial.print(F("Year: ")); Serial.println(year);
  Serial.print(F("Month: ")); Serial.println(month);
  Serial.print(F("Day: ")); Serial.println(day);
  Serial.print(F("Hour: ")); Serial.println(hour);
  Serial.print(F("Minute: ")); Serial.println(minute);
  Serial.print(F("Second: ")); Serial.println(second);

  Serial.println(F("---------------------"));

  // Format the floating point numbers
  dtostrf(latitude, 1, 6, latBuff); // float_val, min_width, digits_after_decimal, char_buffer
  dtostrf(longitude, 1, 6, longBuff);
  dtostrf(speed_kph, 1, 0, speedBuff);
  dtostrf(heading, 1, 0, headBuff);
  dtostrf(altitude, 1, 1, altBuff);
  dtostrf(battLevel, 1, 2, battBuff);

  // Also construct a combined, comma-separated location array
  // (many platforms require this for dashboards, like Adafruit IO):
  sprintf(locBuff, "%s,%s,%s,%s", speedBuff, latBuff, longBuff, altBuff); // This could look like "10,33.123456,-85.123456,120.5"

  // Ensure the connection to the MQTT server is alive (this will make the first
  // connection and automatically reconnect when disconnected). See the MQTT_connect
  // function definition further below.
  MQTT_connect();

  // Now publish all the data to different feeds!
  // The MQTT_publish_checkSuccess handles repetitive stuff.
  // You can see the function near the end of this sketch.
  // For the Adafruit IO dashboard map we send the combined lat/long buffer
  MQTT_publish_checkSuccess(feed_location, locBuff);
  MQTT_publish_checkSuccess(feed_speed, speedBuff); // Included in "location" feed
  MQTT_publish_checkSuccess(feed_head, headBuff);
  MQTT_publish_checkSuccess(feed_alt, altBuff); // Included in "location" feed
  MQTT_publish_checkSuccess(feed_voltage, battBuff);

  // This is our 'wait for incoming subscription packets' busy subloop
  Adafruit_MQTT_Subscribe *subscription;
  while ((subscription = mqtt.readSubscription(5000))) {
    if (subscription == &feed_command) {
      Serial.print(F("*** Got: "));
        TelnetStream.print(F("*** Got: "));
      Serial.println((char *)feed_command.lastread);
        TelnetStream.println((char *)feed_command.lastread);
    }
  }
  /*
    // Control an LED based on what we receive from the command feed subscription!
    if (strcmp(feed_command.lastread, "ON") == 0) {
      Serial.println(F("*** Commanded to turn on LED!"));
      digitalWrite(LED, HIGH);
    }
    else if (strcmp(feed_command.lastread, "OFF") == 0) {
      Serial.println(F("*** Commanded to turn off LED!"));
      digitalWrite(LED, LOW);
    }
  */
  // Delay until next post
  Serial.print(F("Waiting for ")); Serial.print(samplingRate); Serial.println(F(" seconds\r\n"));
    TelnetStream.println(F("Waiting for ")); TelnetStream.print(samplingRate); TelnetStream.println(F(" seconds\r\n"));
  delay(samplingRate * 1000UL); // Delay
}

void moduleSetup() {

  // Software serial:
  fonaSS.begin(115200); // Default SIM7000 shield baud rate

  Serial.println(F("Configuring to 9600 baud"));
    TelnetStream.println(F("Configuring to 9600 baud"));
  fonaSS.println("AT+IPR=9600"); // Set baud rate
    TelnetStream.println("AT+IPR=9600"); // Set baud rate
  delay(100); // Short pause to let the command run
  fonaSS.begin(9600);
  if (! fona.begin(fonaSS)) {
    Serial.println(F("Couldn't find FONA"));
     TelnetStream.println(F("Couldn't find FONA"));
    while (1); // Don't proceed if it couldn't find the device
  }

  type = fona.type();
  Serial.println(F("FONA is OK"));
    TelnetStream.println(F("FONA is OK"));
  Serial.print(F("Found "));
    TelnetStream.print(F("Found "));
  switch (type) {
    case SIM800L:
      Serial.println(F("SIM800L")); break;
    case SIM800H:
      Serial.println(F("SIM800H")); break;
    case SIM808_V1:
      Serial.println(F("SIM808 (v1)")); break;
    case SIM808_V2:
      Serial.println(F("SIM808 (v2)")); break;
    case SIM5320A:
      Serial.println(F("SIM5320A (American)")); break;
    case SIM5320E:
      Serial.println(F("SIM5320E (European)")); break;
    case SIM7000:
      Serial.println(F("SIM7000")); break;
        TelnetStream.println(F("SIM7000")); break;
    case SIM7070:
      Serial.println(F("SIM7070")); break;
    case SIM7500:
      Serial.println(F("SIM7500")); break;
    case SIM7600:
      Serial.println(F("SIM7600")); break;
    default:
      Serial.println(F("???")); break;
  }

  // Print module IMEI number.
  uint8_t imeiLen = fona.getIMEI(imei);
  if (imeiLen > 0) {
    Serial.print("Module IMEI: "); Serial.println(imei);
      TelnetStream.print("Module IMEI: "); TelnetStream.println(imei);
    
  }
}

// Read the module's power supply voltage
float readVin() {
  // Read battery voltage
  if (!fona.getBattVoltage(&battLevel)) Serial.println(F("Failed to read batt"));
  else Serial.print(F("battery = ")); Serial.print(v); Serial.println(F(" v")); TelnetStream.print(F("battery = ")); TelnetStream.print(v); TelnetStream.println(F(" v"));

   
  // Read LiPo battery percentage
  // Note: This will NOT work properly on the LTE shield because the voltage
  // is regulated to 3.6V so you will always read about the same value!
  //  if (!fona.getBattPercent(&battLevel)) Serial.println(F("Failed to read batt"));
  //  else Serial.print(F("BAT % = ")); Serial.print(battLevel); Serial.println(F("%"));

  return battLevel;
}

bool netStatus() {
  int n = fona.getNetworkStatus();

  Serial.print(F("Network status ")); Serial.print(n); Serial.print(F(": "));
    TelnetStream.print(F("Network status "));TelnetStream.print(n); TelnetStream.print(F(": "));
  if (n == 0) Serial.println(F("Not registered")); TelnetStream.println(F("Not registered"));
  if (n == 1) Serial.println(F("Registered (home)")); TelnetStream.println(F("Registered (home)"));
  if (n == 2) Serial.println(F("Not registered (searching)")); TelnetStream.println(F("Not registered (searching)"));
  if (n == 3) Serial.println(F("Denied")); TelnetStream.println(F("Denied"));
  if (n == 4) Serial.println(F("Unknown")); TelnetStream.println(F("Unknown"));
  if (n == 5) Serial.println(F("Registered roaming")); TelnetStream.println(F("Registered roaming"));

  if (!(n == 1 || n == 5)) return false;
  else return true;
}

// Function to connect and reconnect as necessary to the MQTT server.
// Should be called in the loop function and it will take care if connecting.
void MQTT_connect() {
  int8_t ret;

  // Stop if already connected.
  if (mqtt.connected()) {
    return;
  }

  Serial.println("Connecting to MQTT... ");
    TelnetStream.println("Connecting to MQTT... ");

  while ((ret = mqtt.connect()) != 0) { // connect will return 0 for connected
    Serial.println(mqtt.connectErrorString(ret));
      TelnetStream.println(mqtt.connectErrorString(ret));
    Serial.println("Retrying MQTT connection in 5 seconds...");
      TelnetStream.println("Retrying MQTT connection in 5 seconds...");
    mqtt.disconnect();
    delay(5000);  // wait 5 seconds
  }
  Serial.println("MQTT Connected!");
    TelnetStream.println("MQTT Connected!");
}

void MQTT_publish_checkSuccess(Adafruit_MQTT_Publish &feed, const char *feedContent) {
  Serial.println(F("Sending data..."));TelnetStream.println(F("Sending data..."));
  if (! feed.publish(feedContent)) {
    Serial.println(F("Failed"));TelnetStream.println(F("Failed"));
    txfailures++;
  }
  else {
    Serial.println(F("OK!"));TelnetStream.println(F("OK!"));
    txfailures = 0;
  }

  ArduinoOTA.handle();
}